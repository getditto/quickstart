#
# .github/workflows/dotnet-tui-ci.yml
# Workflow for building and testing dotnet-tui
#
---
name: dotnet-tui-ci

on:
  pull_request:
    branches: [main]
    paths:
      - 'dotnet-tui/**'
      - '.github/workflows/dotnet-tui-ci.yml'
  push:
    branches: [main]
    paths:
      - 'dotnet-tui/**'
      - '.github/workflows/dotnet-tui-ci.yml'
  workflow_dispatch:  # Allow manual trigger

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-test:
    name: Build and Test
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    timeout-minutes: 15
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Create .env file
        run: |
          echo "DITTO_APP_ID=${{ secrets.DITTO_APP_ID }}" > .env
          echo "DITTO_PLAYGROUND_TOKEN=${{ secrets.DITTO_PLAYGROUND_TOKEN }}" >> .env
          echo "DITTO_AUTH_URL=${{ secrets.DITTO_AUTH_URL }}" >> .env
          echo "DITTO_WEBSOCKET_URL=${{ secrets.DITTO_WEBSOCKET_URL }}" >> .env
        shell: bash

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json', '**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Restore dependencies
        working-directory: dotnet-tui/DittoDotNetTasksConsole
        run: dotnet restore

      - name: Build
        working-directory: dotnet-tui/DittoDotNetTasksConsole
        run: dotnet build --configuration Release --no-restore

      - name: Verify TUI startup
        working-directory: dotnet-tui/DittoDotNetTasksConsole
        run: |
          # Create a simple test that verifies the app can start
          # Since it's a TUI app, we'll run it with a timeout and check the exit code
          # The app requires terminal interaction, so we'll create a simple wrapper
          
          if [[ "$RUNNER_OS" == "Linux" || "$RUNNER_OS" == "macOS" ]]; then
            # On Unix-like systems, use timeout command
            echo "Testing TUI startup on $RUNNER_OS..."
            
            # Start the app with a 5-second timeout
            # We expect it to be killed by timeout, which is fine
            # We're just checking it doesn't crash immediately
            timeout 5s dotnet run --configuration Release > output.log 2>&1
            EXIT_CODE=$?
            
            # Exit code 1 means Terminal.Gui couldn't open terminal (expected in CI)
            # Exit code 124 means timeout killed it (expected)
            # Exit code 0 means it exited cleanly
            # Any other exit code is a failure
            if [[ $EXIT_CODE -eq 1 || $EXIT_CODE -eq 124 || $EXIT_CODE -eq 0 ]]; then
              echo "‚úÖ TUI app started successfully"
              
              # Check if Ditto connection was attempted
              if grep -q "starting Ditto" output.log || grep -q "Starting TCP server" output.log || grep -q "Error opening terminal" output.log; then
                echo "‚úÖ Found evidence of Ditto initialization and/or terminal error (expected)"
              else
                echo "‚ö†Ô∏è No evidence of Ditto/Tasks initialization found in output"
                cat output.log
              fi
            else
              echo "‚ùå TUI app failed to start (exit code: $EXIT_CODE)"
              cat output.log
              exit 1
            fi
          else
            # On Windows, use a different approach
            echo "Testing TUI startup on Windows..."
            
            # Create a PowerShell script to run the app with timeout
            cat > test-startup.ps1 << 'EOF'
            $process = Start-Process -FilePath "dotnet" -ArgumentList "run", "--configuration", "Release" -PassThru -RedirectStandardOutput "output.log" -RedirectStandardError "error.log"
            
            # Wait up to 5 seconds
            $process | Wait-Process -Timeout 5 -ErrorAction SilentlyContinue
            
            if (!$process.HasExited) {
              $process | Stop-Process -Force
              Write-Host "‚úÖ TUI app started successfully (had to be terminated)"
              exit 0
            } elseif ($process.ExitCode -eq 0 -or $process.ExitCode -eq 1) {
              Write-Host "‚úÖ TUI app exited (exit code: $($process.ExitCode))"
              # Exit code 1 is expected when Terminal.Gui can't open terminal
              exit 0
            } else {
              Write-Host "‚ùå TUI app failed to start (exit code: $($process.ExitCode))"
              Get-Content output.log
              Get-Content error.log
              exit 1
            }
EOF
            
            pwsh -File test-startup.ps1
          fi
        shell: bash

      - name: Upload build artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ matrix.os }}
          path: |
            dotnet-tui/DittoDotNetTasksConsole/bin/
            dotnet-tui/DittoDotNetTasksConsole/obj/
            dotnet-tui/DittoDotNetTasksConsole/output.log
            dotnet-tui/DittoDotNetTasksConsole/error.log

      - name: Generate test report
        if: always()
        run: |
          echo "# .NET TUI Test Report" > test-report.md
          echo "" >> test-report.md
          echo "OS: ${{ matrix.os }}" >> test-report.md
          echo "Status: ${{ job.status }}" >> test-report.md
          echo "" >> test-report.md
          
          if [[ -f "dotnet-tui/DittoDotNetTasksConsole/output.log" ]]; then
            echo "## Application Output" >> test-report.md
            echo '```' >> test-report.md
            head -50 dotnet-tui/DittoDotNetTasksConsole/output.log >> test-report.md || echo "No output captured" >> test-report.md
            echo '```' >> test-report.md
          fi
        shell: bash

      - name: Upload test report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-report-${{ matrix.os }}
          path: test-report.md

  integration-test:
    name: Integration Test
    needs: build-and-test
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Create .env file
        run: |
          echo "DITTO_APP_ID=${{ secrets.DITTO_APP_ID }}" > .env
          echo "DITTO_PLAYGROUND_TOKEN=${{ secrets.DITTO_PLAYGROUND_TOKEN }}" >> .env
          echo "DITTO_AUTH_URL=${{ secrets.DITTO_AUTH_URL }}" >> .env
          echo "DITTO_WEBSOCKET_URL=${{ secrets.DITTO_WEBSOCKET_URL }}" >> .env

      - name: Build
        working-directory: dotnet-tui/DittoDotNetTasksConsole
        run: dotnet build --configuration Release

      - name: Run integration test
        run: |
          # Create a simple C# script to test Ditto connectivity
          cat > test-ditto-connection.csx << 'EOF'
          #r "nuget: Ditto, 4.11.1"
          
          using System;
          using System.Collections.Generic;
          using System.IO;
          using System.Threading.Tasks;
          using DittoSDK;
          
          try
          {
              // Read environment variables
              var lines = File.ReadAllLines(".env");
              var env = new Dictionary<string, string>();
              foreach (var line in lines)
              {
                  if (string.IsNullOrWhiteSpace(line) || line.StartsWith("#")) continue;
                  var parts = line.Split('=', 2);
                  if (parts.Length == 2)
                  {
                      env[parts[0].Trim()] = parts[1].Trim().Trim('"');
                  }
              }
              
              Console.WriteLine("üîß Testing Ditto connection...");
              
              var identity = DittoIdentity.OnlinePlayground(
                  appID: env["DITTO_APP_ID"],
                  token: env["DITTO_PLAYGROUND_TOKEN"],
                  enableDittoCloudSync: true,
                  customAuthURL: env.ContainsKey("DITTO_AUTH_URL") ? env["DITTO_AUTH_URL"] : null
              );
              
              var ditto = new Ditto(identity, path: "./ditto-test");
              
              try
              {
                  ditto.StartSync();
                  Console.WriteLine("‚úÖ Successfully connected to Ditto");
                  
                  // Test accessing the tasks collection
                  var collection = ditto.Store.Collection("tasks");
                  Console.WriteLine("‚úÖ Successfully accessed tasks collection");
                  
                  // Try to query tasks
                  var tasks = collection.FindAll().Exec();
                  Console.WriteLine($"‚úÖ Found {tasks.Count} tasks in the collection");
                  
                  // Create a test task
                  var testId = Guid.NewGuid().ToString();
                  var testTask = new Dictionary<string, object>
                  {
                      ["_id"] = testId,
                      ["title"] = "Test Task from CI",
                      ["done"] = false,
                      ["deleted"] = false
                  };
                  
                  var insertedId = collection.Upsert(testTask);
                  Console.WriteLine($"‚úÖ Successfully created test task with ID: {insertedId}");
                  
                  // Verify the task was created
                  var foundTask = collection.FindByID(new DittoDocumentID(testId)).Exec();
                  if (foundTask != null)
                  {
                      Console.WriteLine("‚úÖ Successfully retrieved the created task");
                  }
                  
                  // Clean up
                  collection.FindByID(new DittoDocumentID(testId)).Remove();
                  Console.WriteLine("‚úÖ Successfully cleaned up test task");
                  
                  Console.WriteLine("\nüéâ All Ditto integration tests passed!");
              }
              finally
              {
                  ditto.StopSync();
                  ditto.Dispose();
              }
          }
          catch (Exception ex)
          {
              Console.WriteLine($"‚ùå Integration test failed: {ex.Message}");
              Environment.Exit(1);
          }
          EOF
          
          # Run the integration test
          dotnet script test-ditto-connection.csx

      - name: Comment PR with results
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ job.status }}';
            const runUrl = '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}';
            
            const body = `## üñ•Ô∏è .NET TUI Test Results
            
            **Status:** ${status === 'success' ? '‚úÖ Passed' : '‚ùå Failed'}
            **Build:** [#${{ github.run_number }}](${runUrl})
            
            ### Tested Platforms:
            - Ubuntu (Linux)
            - Windows
            - macOS
            
            ### Tests Performed:
            - ‚úì Build verification
            - ‚úì TUI startup test
            - ‚úì Ditto connection test
            - ‚úì Task collection operations
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
