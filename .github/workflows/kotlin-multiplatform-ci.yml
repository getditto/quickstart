name: Kotlin Multiplatform CI

on:
  push:
    branches: [ main ]
    paths:
      - 'kotlin-multiplatform/**'
      - '.github/workflows/kotlin-multiplatform-ci.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'kotlin-multiplatform/**'
      - '.github/workflows/kotlin-multiplatform-ci.yml'
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  lint:
    name: Lint (ubuntu-latest)
    runs-on: ubuntu-latest
    timeout-minutes: 15
    defaults:
      run:
        working-directory: kotlin-multiplatform
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Java
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'
        cache: 'gradle'
    
    - name: Cache Gradle dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
          kotlin-multiplatform/.gradle
        key: gradle-${{ runner.os }}-${{ hashFiles('kotlin-multiplatform/gradle/wrapper/gradle-wrapper.properties', 'kotlin-multiplatform/**/*.gradle*', 'kotlin-multiplatform/gradle/libs.versions.toml') }}
        restore-keys: |
          gradle-${{ runner.os }}-
    
    - name: Create test .env file
      run: |
        echo "DITTO_APP_ID=test_app_id" > ../.env
        echo "DITTO_PLAYGROUND_TOKEN=test_token" >> ../.env
        echo "DITTO_AUTH_URL=https://test.com" >> ../.env
        echo "DITTO_WEBSOCKET_URL=wss://test.com" >> ../.env
    
    - name: Make gradlew executable
      run: chmod +x gradlew
    
    - name: Run Detekt lint
      run: ./gradlew detekt --stacktrace
    
    - name: Upload Detekt reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: detekt-reports
        path: kotlin-multiplatform/composeApp/build/reports/detekt/

  build-android:
    name: Build Android (ubuntu-latest)
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: lint
    outputs:
      test_doc_title: ${{ steps.test_doc.outputs.test_doc_title }}
    defaults:
      run:
        working-directory: kotlin-multiplatform
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Java
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'
        cache: 'gradle'
    
    - name: Setup Android SDK
      uses: android-actions/setup-android@v3
    
    - name: Cache Gradle dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
          kotlin-multiplatform/.gradle
        key: gradle-${{ runner.os }}-${{ hashFiles('kotlin-multiplatform/gradle/wrapper/gradle-wrapper.properties', 'kotlin-multiplatform/**/*.gradle*', 'kotlin-multiplatform/gradle/libs.versions.toml') }}
        restore-keys: |
          gradle-${{ runner.os }}-
    
    - name: Generate test document title
      id: test_doc
      run: |
        # Create a unique GitHub test document with inverted timestamp to appear at top
        TIMESTAMP=$(date +%s)
        INVERTED_TIMESTAMP=$((9999999999 - TIMESTAMP))
        DOC_ID="${INVERTED_TIMESTAMP}_kmp_android_ci_test_${{ github.run_id }}_${{ github.run_number }}"
        DOC_TITLE="${INVERTED_TIMESTAMP}_kmp_android_ci_test_${{ github.run_id }}_${{ github.run_number }}"
        
        echo "test_doc_id=$DOC_ID" >> $GITHUB_OUTPUT
        echo "test_doc_title=$DOC_TITLE" >> $GITHUB_OUTPUT
        echo "📝 Generated test document (inverted timestamp for top position)"
        echo "📝 ID: '${DOC_ID}'"
        echo "📝 Title: '${DOC_TITLE}'"
        echo "📝 Timestamp: ${TIMESTAMP} → Inverted: ${INVERTED_TIMESTAMP}"
    
    - name: Create production .env file
      run: |
        echo "DITTO_APP_ID=${{ secrets.DITTO_APP_ID }}" > ../.env
        echo "DITTO_PLAYGROUND_TOKEN=${{ secrets.DITTO_PLAYGROUND_TOKEN }}" >> ../.env
        echo "DITTO_AUTH_URL=${{ secrets.DITTO_AUTH_URL }}" >> ../.env
        echo "DITTO_WEBSOCKET_URL=${{ secrets.DITTO_WEBSOCKET_URL }}" >> ../.env
    
    - name: Make gradlew executable
      run: chmod +x gradlew
    
    - name: Build Android APKs
      env:
        TEST_DOCUMENT_TITLE: ${{ steps.test_doc.outputs.test_doc_title }}
      run: ./gradlew :composeApp:assembleDebug :composeApp:assembleDebugAndroidTest --stacktrace
    
    - name: Upload APK artifacts
      uses: actions/upload-artifact@v4
      with:
        name: android-kmp-apks-${{ github.run_number }}
        path: |
          kotlin-multiplatform/composeApp/build/outputs/apk/debug/composeApp-debug.apk
          kotlin-multiplatform/composeApp/build/outputs/apk/androidTest/debug/composeApp-debug-androidTest.apk
        retention-days: 1

  build-ios:
    name: Build iOS (macos-latest)
    runs-on: macos-latest
    timeout-minutes: 30
    needs: lint
    outputs:
      test_doc_title: ${{ steps.test_doc.outputs.test_doc_title }}
      ios-build-success: ${{ steps.build-status.outputs.success }}
    defaults:
      run:
        working-directory: kotlin-multiplatform
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Java
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'
        cache: 'gradle'
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: 'latest-stable'
    
    - name: Cache Gradle dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
          kotlin-multiplatform/.gradle
        key: gradle-${{ runner.os }}-${{ hashFiles('kotlin-multiplatform/gradle/wrapper/gradle-wrapper.properties', 'kotlin-multiplatform/**/*.gradle*', 'kotlin-multiplatform/gradle/libs.versions.toml') }}
        restore-keys: |
          gradle-${{ runner.os }}-
    
    - name: Generate test document title
      id: test_doc
      run: |
        TIMESTAMP=$(date +%s)
        INVERTED_TIMESTAMP=$((9999999999 - TIMESTAMP))
        DOC_ID="${INVERTED_TIMESTAMP}_kmp_ios_ci_test_${{ github.run_id }}_${{ github.run_number }}"
        DOC_TITLE="${INVERTED_TIMESTAMP}_kmp_ios_ci_test_${{ github.run_id }}_${{ github.run_number }}"
        echo "test_doc_id=$DOC_ID" >> $GITHUB_OUTPUT
        echo "test_doc_title=$DOC_TITLE" >> $GITHUB_OUTPUT
    
    - name: Write production .env
      run: |
        echo "DITTO_APP_ID=${{ secrets.DITTO_APP_ID }}" > ../.env
        echo "DITTO_PLAYGROUND_TOKEN=${{ secrets.DITTO_PLAYGROUND_TOKEN }}" >> ../.env
        echo "DITTO_AUTH_URL=${{ secrets.DITTO_AUTH_URL }}" >> ../.env
        echo "DITTO_WEBSOCKET_URL=${{ secrets.DITTO_WEBSOCKET_URL }}" >> ../.env
    
    - name: Make gradlew executable
      run: chmod +x gradlew
    
    - name: Build KMP iOS frameworks (sim + device)
      run: |
        ./gradlew :composeApp:linkDebugFrameworkIosSimulatorArm64 --stacktrace
        ./gradlew :composeApp:linkDebugFrameworkIosArm64 --stacktrace
    
    # ---- iOS app build without archive/signing (more reliable on CI) ----
    - name: Prepare Xcode container (project/workspace + CocoaPods)
      run: |
        set -euo pipefail
        if [ -f "iosApp/Podfile" ]; then
          echo "Podfile found → installing pods"
          sudo gem install cocoapods --no-document
          cd iosApp
          pod repo update
          pod install
          cd ..
        fi
        
        if [ -f "iosApp/iosApp.xcworkspace" ]; then
          echo "XCWORKSPACE=1" >> $GITHUB_ENV
          CONTAINER="iosApp/iosApp.xcworkspace"
          CONTAINER_FLAG="-workspace"
        else
          echo "XCWORKSPACE=0" >> $GITHUB_ENV
          CONTAINER="iosApp/iosApp.xcodeproj"
          CONTAINER_FLAG="-project"
        fi
        
        echo "CONTAINER=$CONTAINER" >> $GITHUB_ENV
        echo "CONTAINER_FLAG=$CONTAINER_FLAG" >> $GITHUB_ENV
        
        echo "Available schemes:"
        xcodebuild -list $CONTAINER_FLAG "$CONTAINER"
    
    - name: Build device .app (no signing)
      run: |
        set -euo pipefail
        DERIVED="$PWD/build/DerivedData"
        PRODUCTS="$DERIVED/Build/Products"
        
        xcodebuild \
          $CONTAINER_FLAG "$CONTAINER" \
          -scheme iosApp \
          -configuration Debug \
          -sdk iphoneos \
          -derivedDataPath "$DERIVED" \
          CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY="" \
          ENABLE_BITCODE=NO \
          ONLY_ACTIVE_ARCH=NO \
          build
        
        echo "Searching for device .app…"
        APP_DIR=$(find "$PRODUCTS/Debug-iphoneos" -maxdepth 1 -type d -name "*.app" | head -1 || true)
        if [ -z "${APP_DIR:-}" ]; then
          echo "❌ Could not locate Debug-iphoneos/*.app. Dumping tree for debugging:"
          find "$PRODUCTS" -maxdepth 3 -print
          exit 1
        fi
        echo "APP_DIR=$APP_DIR" >> $GITHUB_ENV
        echo "✅ Found app: $APP_DIR"
    
    - name: Create unsigned .ipa for BrowserStack
      run: |
        set -euo pipefail
        mkdir -p build/Payload
        cp -R "$APP_DIR" build/Payload/
        (cd build && zip -qry iosApp-unsigned.ipa Payload && rm -rf Payload)
        test -f build/iosApp-unsigned.ipa || (echo "❌ IPA not created" && exit 1)
        ls -la build/iosApp-unsigned.ipa
    
    - name: Upload iOS IPA Artifact
      uses: actions/upload-artifact@v4
      with:
        name: ios-kmp-ipa-${{ github.run_number }}
        path: kotlin-multiplatform/build/iosApp-unsigned.ipa
        retention-days: 1
    
    - name: Set build status
      id: build-status
      run: echo "success=true" >> $GITHUB_OUTPUT

  build-desktop:
    name: Build Desktop (ubuntu-latest)
    runs-on: ubuntu-latest
    timeout-minutes: 20
    defaults:
      run:
        working-directory: kotlin-multiplatform
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Java
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'
        cache: 'gradle'
    
    - name: Cache Gradle dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
          kotlin-multiplatform/.gradle
        key: gradle-${{ runner.os }}-${{ hashFiles('kotlin-multiplatform/gradle/wrapper/gradle-wrapper.properties', 'kotlin-multiplatform/**/*.gradle*', 'kotlin-multiplatform/gradle/libs.versions.toml') }}
        restore-keys: |
          gradle-${{ runner.os }}-
    
    - name: Create test .env file
      run: |
        echo "DITTO_APP_ID=test_app_id" > ../.env
        echo "DITTO_PLAYGROUND_TOKEN=test_token" >> ../.env
        echo "DITTO_AUTH_URL=https://test.com" >> ../.env
        echo "DITTO_WEBSOCKET_URL=wss://test.com" >> ../.env
    
    - name: Make gradlew executable
      run: chmod +x gradlew
    
    - name: Build Desktop application
      run: ./gradlew :composeApp:packageDistributionForCurrentOS --stacktrace
    
    - name: Upload Desktop build outputs
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: desktop-build-outputs
        path: |
          kotlin-multiplatform/composeApp/build/compose/binaries/main/
          kotlin-multiplatform/composeApp/build/reports/tests/desktopTest/

  browserstack-android:
    name: BrowserStack Android Testing
    runs-on: ubuntu-latest
    needs: build-android
    if: github.event_name == 'push' || github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch'
    timeout-minutes: 45
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Download Android APK artifacts
      uses: actions/download-artifact@v4
      with:
        name: android-kmp-apks-${{ github.run_number }}
        path: kotlin-multiplatform/composeApp/build/outputs/apk/
    
    - name: Insert test document into Ditto Cloud
      run: |
        # Use the same document title that was built into the APK
        DOC_TITLE="${{ needs.build-android.outputs.test_doc_title }}"
        DOC_ID="$DOC_TITLE"
        
        echo "📝 Inserting test document that matches build-time configuration"
        echo "📝 ID: '${DOC_ID}'"
        echo "📝 Title: '${DOC_TITLE}'"
        
        # Insert document using Ditto API v4
        RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
          -H 'Content-type: application/json' \
          -H "Authorization: Bearer ${{ secrets.DITTO_API_KEY }}" \
          -d "{
            \"statement\": \"INSERT INTO tasks DOCUMENTS (:newTask) ON ID CONFLICT DO UPDATE\",
            \"args\": {
              \"newTask\": {
                \"_id\": \"${DOC_ID}\",
                \"text\": \"${DOC_TITLE}\",
                \"isCompleted\": false
              }
            }
          }" \
        "https://${{ secrets.DITTO_API_URL }}/api/v4/store/execute")
        
        # Extract HTTP status code and response body
        HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
        BODY=$(echo "$RESPONSE" | sed '$d')
        
        # Check if insertion was successful
        if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 201 ]; then
          echo "✓ Successfully inserted test document with ID: ${DOC_ID}"
          echo "✓ Document title: ${DOC_TITLE}"
        else
          echo "❌ Failed to insert document. HTTP Status: $HTTP_CODE"
          echo "Response: $BODY"
          exit 1
        fi
    
    - name: Upload APKs to BrowserStack
      id: upload
      run: |
        CREDS="${{ secrets.BROWSERSTACK_USERNAME }}:${{ secrets.BROWSERSTACK_ACCESS_KEY }}"

        # 1. Upload AUT (composeApp-debug.apk)
        APP_UPLOAD_RESPONSE=$(curl -u "$CREDS" \
          -X POST "https://api-cloud.browserstack.com/app-automate/espresso/v2/app" \
          -F "file=@kotlin-multiplatform/composeApp/build/outputs/apk/debug/composeApp-debug.apk" \
          -F "custom_id=ditto-kotlin-multiplatform-app")
        APP_URL=$(echo "$APP_UPLOAD_RESPONSE" | jq -r .app_url)
        echo "app_url=$APP_URL" >> "$GITHUB_OUTPUT"

        # 2. Upload Espresso test-suite (composeApp-debug-androidTest.apk)
        TEST_UPLOAD_RESPONSE=$(curl -u "$CREDS" \
          -X POST "https://api-cloud.browserstack.com/app-automate/espresso/v2/test-suite" \
          -F "file=@kotlin-multiplatform/composeApp/build/outputs/apk/androidTest/debug/composeApp-debug-androidTest.apk" \
          -F "custom_id=ditto-kotlin-multiplatform-test")
        TEST_URL=$(echo "$TEST_UPLOAD_RESPONSE" | jq -r .test_suite_url)
        echo "test_url=$TEST_URL" >> "$GITHUB_OUTPUT"
    
    - name: Execute tests on BrowserStack
      id: test
      run: |
        # Validate inputs before creating test execution request
        APP_URL="${{ steps.upload.outputs.app_url }}"
        TEST_URL="${{ steps.upload.outputs.test_url }}"
        
        echo "App URL: $APP_URL"
        echo "Test URL: $TEST_URL"
        
        if [ -z "$APP_URL" ] || [ "$APP_URL" = "null" ]; then
          echo "Error: No valid app URL available"
          exit 1
        fi
        
        if [ -z "$TEST_URL" ] || [ "$TEST_URL" = "null" ]; then
          echo "Error: No valid test URL available"
          exit 1
        fi
        
        # Create test execution request with instrumentationOptions
        TITLE="${{ needs.build-android.outputs.test_doc_title }}"
        
        BUILD_RESPONSE=$(curl -u "${{ secrets.BROWSERSTACK_USERNAME }}:${{ secrets.BROWSERSTACK_ACCESS_KEY }}" \
          -X POST "https://api-cloud.browserstack.com/app-automate/espresso/v2/build" \
          -H "Content-Type: application/json" \
          -d "{
            \"app\": \"$APP_URL\",
            \"testSuite\": \"$TEST_URL\",
            \"devices\": [
              \"Google Pixel 8-14.0\",
              \"Samsung Galaxy S23-13.0\",
              \"Google Pixel 6-12.0\"
            ],
            \"project\": \"Ditto Kotlin Multiplatform\",
            \"buildName\": \"Build #${{ github.run_number }}\",
            \"buildTag\": \"${{ github.ref_name }}\",
            \"deviceLogs\": true,
            \"video\": true,
            \"networkLogs\": true,
            \"autoGrantPermissions\": true,
            \"instrumentationOptions\": {
              \"DITTO_TASK_ID\": \"$TITLE\"
            }
          }")
        
        echo "BrowserStack API Response:"
        echo "$BUILD_RESPONSE"
        
        BUILD_ID=$(echo "$BUILD_RESPONSE" | jq -r .build_id)
        
        # Check if BUILD_ID is null or empty
        if [ "$BUILD_ID" = "null" ] || [ -z "$BUILD_ID" ]; then
          echo "Error: Failed to create BrowserStack build"
          echo "Response: $BUILD_RESPONSE"
          exit 1
        fi
        
        echo "build_id=$BUILD_ID" >> $GITHUB_OUTPUT
        echo "Build started with ID: $BUILD_ID"
    
    - name: Wait for BrowserStack tests to complete
      run: |
        BUILD_ID="${{ steps.test.outputs.build_id }}"
        
        # Validate BUILD_ID before proceeding
        if [ "$BUILD_ID" = "null" ] || [ -z "$BUILD_ID" ]; then
          echo "Error: No valid BUILD_ID available. Skipping test monitoring."
          exit 1
        fi
        
        MAX_WAIT_TIME=1800  # 30 minutes
        CHECK_INTERVAL=30   # Check every 30 seconds
        ELAPSED=0
        
        while [ $ELAPSED -lt $MAX_WAIT_TIME ]; do
          BUILD_STATUS_RESPONSE=$(curl -s -u "${{ secrets.BROWSERSTACK_USERNAME }}:${{ secrets.BROWSERSTACK_ACCESS_KEY }}" \
            "https://api-cloud.browserstack.com/app-automate/espresso/v2/builds/$BUILD_ID")
          
          BUILD_STATUS=$(echo "$BUILD_STATUS_RESPONSE" | jq -r .status)
          
          # Check for API errors
          if [ "$BUILD_STATUS" = "null" ] || [ -z "$BUILD_STATUS" ]; then
            echo "Error getting build status. Response: $BUILD_STATUS_RESPONSE"
            sleep $CHECK_INTERVAL
            ELAPSED=$((ELAPSED + CHECK_INTERVAL))
            continue
          fi
          
          echo "Build status: $BUILD_STATUS (elapsed: ${ELAPSED}s)"
          
          # Check for completion states
          if [ "$BUILD_STATUS" = "done" ] || [ "$BUILD_STATUS" = "failed" ] || [ "$BUILD_STATUS" = "error" ] || [ "$BUILD_STATUS" = "passed" ] || [ "$BUILD_STATUS" = "completed" ]; then
            echo "Build completed with status: $BUILD_STATUS"
            break
          fi
          
          sleep $CHECK_INTERVAL
          ELAPSED=$((ELAPSED + CHECK_INTERVAL))
        done
        
        # Get final results
        FINAL_RESULT=$(curl -s -u "${{ secrets.BROWSERSTACK_USERNAME }}:${{ secrets.BROWSERSTACK_ACCESS_KEY }}" \
          "https://api-cloud.browserstack.com/app-automate/espresso/v2/builds/$BUILD_ID")
        
        echo "Final build result:"
        echo "$FINAL_RESULT" | jq .
        
        # Check if we got valid results
        if echo "$FINAL_RESULT" | jq -e .devices > /dev/null 2>&1; then
          # Check if the overall build passed
          BUILD_STATUS=$(echo "$FINAL_RESULT" | jq -r .status)
          if [ "$BUILD_STATUS" != "passed" ]; then
            echo "Build failed with status: $BUILD_STATUS"
            exit 1
          else
            echo "All tests passed successfully!"
          fi
        else
          echo "Warning: Could not parse final results"
          echo "Raw response: $FINAL_RESULT"
        fi

  browserstack-ios:
    name: BrowserStack iOS Testing  
    runs-on: macos-latest
    needs: build-ios
    if: needs.build-ios.outputs.ios-build-success == 'true'
    timeout-minutes: 45
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: 'latest-stable'
    
    - name: Create production .env file
      run: |
        echo "DITTO_APP_ID=${{ secrets.DITTO_APP_ID }}" > .env
        echo "DITTO_PLAYGROUND_TOKEN=${{ secrets.DITTO_PLAYGROUND_TOKEN }}" >> .env
        echo "DITTO_AUTH_URL=${{ secrets.DITTO_AUTH_URL }}" >> .env
        echo "DITTO_WEBSOCKET_URL=${{ secrets.DITTO_WEBSOCKET_URL }}" >> .env
      working-directory: kotlin-multiplatform
    
    - name: Download iOS IPA Artifact
      uses: actions/download-artifact@v4
      with:
        name: ios-kmp-ipa-${{ github.run_number }}
        path: ./kotlin-multiplatform/build/
    
    - name: Build XCUITest Bundle for BrowserStack
      id: build_test_bundle
      working-directory: kotlin-multiplatform/iosApp
      run: |
        set -euo pipefail

        echo "🧪 build-for-testing (device) with GitHub run info injected..."
        DERIVED="$PWD/build/DerivedData"
        PRODUCTS_DIR="$DERIVED/Build/Products"

        # Build iOS UI tests for device
        xcodebuild build-for-testing \
          -project iosApp.xcodeproj \
          -scheme iosApp \
          -configuration Debug \
          -destination 'generic/platform=iOS' \
          -derivedDataPath "$DERIVED" \
          CODE_SIGNING_ALLOWED=NO \
          CODE_SIGNING_REQUIRED=NO \
          GITHUB_RUN_ID=${{ github.run_id }} \
          GITHUB_RUN_NUMBER=${{ github.run_number }}

        echo "🔍 Looking for Runner.app (device) and .xctestrun…"
        # Runner.app must come from Debug-iphoneos (device), not simulator
        RUNNER_APP=$(find "$PRODUCTS_DIR" -type d -path "*/Debug-iphoneos/*-Runner.app" -print -quit || true)
        XCTESTRUN=$(find "$PRODUCTS_DIR" -maxdepth 1 -type f -name "*.xctestrun" -print -quit || true)

        if [[ -z "${RUNNER_APP:-}" || ! -d "$RUNNER_APP" ]]; then
          echo "❌ Runner.app not found under $PRODUCTS_DIR"
          find "$PRODUCTS_DIR" -type d -name "*-Runner.app" || true
          exit 1
        fi

        echo "✅ Runner: $RUNNER_APP"

        # Create ZIP with Runner.app at ZIP ROOT (as BrowserStack expects)
        OUT_DIR="$PWD/../../build"
        mkdir -p "$OUT_DIR"
        OUT_ZIP="$OUT_DIR/KMPUITests.zip"
        rm -f "$OUT_ZIP"

        echo "📦 Creating $OUT_ZIP with root: [$(basename "$RUNNER_APP")]"
        ( cd "$(dirname "$RUNNER_APP")" && zip -qry "$OUT_ZIP" "$(basename "$RUNNER_APP")" )

        echo "🔍 ZIP contents:"
        unzip -l "$OUT_ZIP" | sed -n '1,120p'

        echo "test_bundle_path=$OUT_ZIP" >> "$GITHUB_OUTPUT"
        echo "✅ XCUITest test-suite zip ready: $OUT_ZIP"
    
    - name: Insert test document into Ditto Cloud
      run: |
        # Use the same document title that was built into the IPA
        DOC_TITLE="${{ needs.build-ios.outputs.test_doc_title }}"
        DOC_ID="$DOC_TITLE"
        
        echo "📝 Inserting test document that matches build-time configuration"
        echo "📝 ID: '${DOC_ID}'"
        echo "📝 Title: '${DOC_TITLE}'"
        
        # Insert document using Ditto API v4
        RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
          -H 'Content-type: application/json' \
          -H "Authorization: Bearer ${{ secrets.DITTO_API_KEY }}" \
          -d "{
            \"statement\": \"INSERT INTO tasks DOCUMENTS (:newTask) ON ID CONFLICT DO UPDATE\",
            \"args\": {
              \"newTask\": {
                \"_id\": \"${DOC_ID}\",
                \"text\": \"${DOC_TITLE}\",
                \"isCompleted\": false
              }
            }
          }" \
        "https://${{ secrets.DITTO_API_URL }}/api/v4/store/execute")
        
        # Extract HTTP status code and response body
        HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
        BODY=$(echo "$RESPONSE" | sed '$d')
        
        # Check if insertion was successful
        if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 201 ]; then
          echo "✓ Successfully inserted test document with ID: ${DOC_ID}"
          echo "✓ Document title: ${DOC_TITLE}"
        else
          echo "❌ Failed to insert document. HTTP Status: $HTTP_CODE"
          echo "Response: $BODY"
          exit 1
        fi
    
    - name: Upload App and Test Bundle to BrowserStack
      id: upload
      run: |
        echo "📤 Uploading KMP iOS app and XCUITest bundle to BrowserStack..."
        
        IPA_FILE="./kotlin-multiplatform/build/iosApp-unsigned.ipa"
        TEST_BUNDLE="${{ steps.build_test_bundle.outputs.test_bundle_path }}"
        
        echo "📱 App file: $IPA_FILE"
        echo "🧪 Test bundle: $TEST_BUNDLE"
        
        # Validate both files exist
        if [ ! -f "$IPA_FILE" ]; then
          echo "❌ IPA file not found: $IPA_FILE"
          ls -la ./kotlin-multiplatform/build/ || true
          exit 1
        fi
        
        if [ ! -f "$TEST_BUNDLE" ]; then
          echo "❌ Test bundle not found: $TEST_BUNDLE"
          exit 1
        fi
        
        # Upload app to BrowserStack XCUITest v2 API
        echo "📱 Uploading KMP iOS app..."
        APP_UPLOAD_RESPONSE=$(curl --fail --silent --show-error -u "${{ secrets.BROWSERSTACK_USERNAME }}:${{ secrets.BROWSERSTACK_ACCESS_KEY }}" \
          -X POST "https://api-cloud.browserstack.com/app-automate/xcuitest/v2/app" \
          -F "file=@$IPA_FILE" \
          -F "custom_id=ditto-kmp-ios-app")
        
        echo "App upload response: $APP_UPLOAD_RESPONSE"
        APP_URL=$(echo "$APP_UPLOAD_RESPONSE" | jq -r .app_url)
        
        if [ "$APP_URL" = "null" ] || [ -z "$APP_URL" ]; then
          echo "❌ Failed to upload app"
          echo "Response: $APP_UPLOAD_RESPONSE"
          exit 1
        fi
        
        # Upload test bundle to XCUITest v2 API  
        echo "🧪 Uploading test bundle..."
        TEST_UPLOAD_RESPONSE=$(curl -s -w "\n%{http_code}" -u "${{ secrets.BROWSERSTACK_USERNAME }}:${{ secrets.BROWSERSTACK_ACCESS_KEY }}" \
          -X POST "https://api-cloud.browserstack.com/app-automate/xcuitest/v2/test-suite" \
          -F "file=@$TEST_BUNDLE")

        HTTP_CODE=$(echo "$TEST_UPLOAD_RESPONSE" | tail -n1)
        BODY=$(echo "$TEST_UPLOAD_RESPONSE" | sed '$d')

        echo "Test upload HTTP $HTTP_CODE"
        echo "Response body: $BODY"

        if [ "$HTTP_CODE" -ne 200 ] && [ "$HTTP_CODE" -ne 201 ]; then
          echo "❌ Upload failed"; exit 1
        fi

        # Prefer test_suite_url, fallback to test_url
        TEST_URL=$(echo "$BODY" | jq -r '.test_suite_url // .test_url // empty')
        
        if [ -z "$TEST_URL" ]; then
          echo "❌ Failed to upload test bundle - no test suite URL in response"
          echo "Response: $BODY"
          exit 1
        fi
        
        echo "app_url=$APP_URL" >> $GITHUB_OUTPUT
        echo "test_url=$TEST_URL" >> $GITHUB_OUTPUT
        echo "✅ App and test bundle uploaded successfully"
        echo "📱 App URL: $APP_URL"
        echo "🧪 Test URL: $TEST_URL"
    
    - name: Execute XCUITest on BrowserStack
      id: test
      run: |
        # Validate inputs
        APP_URL="${{ steps.upload.outputs.app_url }}"
        TEST_URL="${{ steps.upload.outputs.test_url }}"
        DOC_TITLE="${{ needs.build-ios.outputs.test_doc_title }}"
        
        echo "App URL: $APP_URL"
        echo "Test URL: $TEST_URL"
        echo "Test Document Title: $DOC_TITLE"
        
        if [ -z "$APP_URL" ] || [ "$APP_URL" = "null" ]; then
          echo "Error: No valid app URL available"
          exit 1
        fi
        
        if [ -z "$TEST_URL" ] || [ "$TEST_URL" = "null" ]; then
          echo "Error: No valid test URL available"
          exit 1
        fi
        
        # Create XCUITest execution request using v2 API with setEnvVariables
        BUILD_RESPONSE=$(curl -u "${{ secrets.BROWSERSTACK_USERNAME }}:${{ secrets.BROWSERSTACK_ACCESS_KEY }}" \
          -X POST "https://api-cloud.browserstack.com/app-automate/xcuitest/v2/build" \
          -H "Content-Type: application/json" \
          -d "{
            \"app\": \"$APP_URL\",
            \"testSuite\": \"$TEST_URL\",
            \"devices\": [\"iPhone 15 Pro-17\"],
            \"project\": \"Ditto Kotlin Multiplatform\",
            \"buildName\": \"Build #${{ github.run_number }}\",
            \"buildTag\": \"${{ github.ref_name }}\",
            \"deviceLogs\": true,
            \"video\": true,
            \"networkLogs\": true,
            \"setEnvVariables\": {
              \"GITHUB_RUN_ID\": \"${{ github.run_id }}\",
              \"GITHUB_RUN_NUMBER\": \"${{ github.run_number }}\",
              \"GITHUB_TEST_DOC_TITLE\": \"$DOC_TITLE\"
            }
          }")
        
        echo "BrowserStack API Response:"
        echo "$BUILD_RESPONSE"
        
        BUILD_ID=$(echo "$BUILD_RESPONSE" | jq -r .build_id)
        
        if [ "$BUILD_ID" = "null" ] || [ -z "$BUILD_ID" ]; then
          echo "Error: Failed to create BrowserStack build"
          echo "Response: $BUILD_RESPONSE"
          exit 1
        fi
        
        echo "build_id=$BUILD_ID" >> $GITHUB_OUTPUT
        echo "Build started with ID: $BUILD_ID"

    - name: Wait for XCUITest to complete
      run: |
        BUILD_ID="${{ steps.test.outputs.build_id }}"
        
        if [ "$BUILD_ID" = "null" ] || [ -z "$BUILD_ID" ]; then
          echo "Error: No BUILD_ID available"
          exit 1
        fi
        
        MAX_WAIT_TIME=900  # 15 minutes
        CHECK_INTERVAL=30   # Check every 30 seconds
        ELAPSED=0
        
        while [ $ELAPSED -lt $MAX_WAIT_TIME ]; do
          BUILD_STATUS_RESPONSE=$(curl -s -u "${{ secrets.BROWSERSTACK_USERNAME }}:${{ secrets.BROWSERSTACK_ACCESS_KEY }}" \
            "https://api-cloud.browserstack.com/app-automate/xcuitest/v2/builds/$BUILD_ID")
          
          BUILD_STATUS=$(echo "$BUILD_STATUS_RESPONSE" | jq -r .status)
          
          if [ "$BUILD_STATUS" = "null" ] || [ -z "$BUILD_STATUS" ]; then
            echo "Error getting build status. Response: $BUILD_STATUS_RESPONSE"
            sleep $CHECK_INTERVAL
            ELAPSED=$((ELAPSED + CHECK_INTERVAL))
            continue
          fi
          
          echo "Build status: $BUILD_STATUS (elapsed: ${ELAPSED}s)"
          
          if [ "$BUILD_STATUS" = "done" ] || [ "$BUILD_STATUS" = "failed" ] || [ "$BUILD_STATUS" = "error" ] || [ "$BUILD_STATUS" = "passed" ] || [ "$BUILD_STATUS" = "completed" ]; then
            echo "Build completed with status: $BUILD_STATUS"
            break
          fi
          
          sleep $CHECK_INTERVAL
          ELAPSED=$((ELAPSED + CHECK_INTERVAL))
        done
        
        # Get final results
        FINAL_RESULT=$(curl -s -u "${{ secrets.BROWSERSTACK_USERNAME }}:${{ secrets.BROWSERSTACK_ACCESS_KEY }}" \
          "https://api-cloud.browserstack.com/app-automate/xcuitest/v2/builds/$BUILD_ID")
        
        echo "Final build result:"
        echo "$FINAL_RESULT" | jq .
        
        # Check final status
        BUILD_STATUS=$(echo "$FINAL_RESULT" | jq -r .status)
        if [ "$BUILD_STATUS" != "passed" ]; then
          echo "Build failed with status: $BUILD_STATUS"
          exit 1
        else
          echo "All tests passed successfully!"
        fi

  build-summary:
    name: Build Summary
    runs-on: ubuntu-latest
    needs: [lint, build-android, build-ios, build-desktop, browserstack-android, browserstack-ios]
    if: always()
    
    steps:
    - name: Check build results
      run: |
        echo "## Kotlin Multiplatform CI Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Target | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|--------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Lint | ${{ needs.lint.result == 'success' && '✅ Passed' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Android Build | ${{ needs.build-android.result == 'success' && '✅ Passed' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| iOS Build | ${{ needs.build-ios.result == 'success' && '✅ Passed' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Desktop Build | ${{ needs.build-desktop.result == 'success' && '✅ Passed' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Android BrowserStack | ${{ needs.browserstack-android.result == 'success' && '✅ Passed' || (needs.browserstack-android.result == 'skipped' && '⏭️ Skipped') || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| iOS BrowserStack | ${{ needs.browserstack-ios.result == 'success' && '✅ Passed' || (needs.browserstack-ios.result == 'skipped' && '⏭️ Skipped') || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Check core build results
        if [[ "${{ needs.lint.result }}" != "success" ]] || \
           [[ "${{ needs.build-android.result }}" != "success" ]] || \
           [[ "${{ needs.build-ios.result }}" != "success" ]] || \
           [[ "${{ needs.build-desktop.result }}" != "success" ]]; then
          echo "❌ Core builds failed" >> $GITHUB_STEP_SUMMARY
          exit 1
        else
          echo "✅ All core builds passed successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Testing results summary
          if [[ "${{ needs.browserstack-android.result }}" == "success" ]] && [[ "${{ needs.browserstack-ios.result }}" == "success" ]]; then
            echo "🚀 **Full end-to-end success!** All builds passed, Android BrowserStack testing completed, and iOS BrowserStack testing passed." >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.browserstack-android.result }}" == "success" ]]; then
            echo "✅ Android BrowserStack testing passed. iOS BrowserStack testing was skipped or failed." >> $GITHUB_STEP_SUMMARY  
          elif [[ "${{ needs.browserstack-ios.result }}" == "success" ]]; then
            echo "✅ iOS BrowserStack testing passed. Android BrowserStack testing was skipped or failed." >> $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ Core builds passed but testing had issues. Check testing logs above." >> $GITHUB_STEP_SUMMARY
          fi
        fi