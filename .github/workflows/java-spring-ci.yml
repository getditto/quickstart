#
# .github/workflows/java-spring-ci.yml
# Workflow for building and testing java-spring with BrowserStack integration
#
---
name: java-spring-ci

on:
  pull_request:
    branches: [main]
    paths:
      - 'java-spring/**'
      - '.github/workflows/java-spring-ci.yml'
  push:
    branches: [main]
    paths:
      - 'java-spring/**'
      - '.github/workflows/java-spring-ci.yml'
  workflow_dispatch:  # Allow manual trigger

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-test:
    name: Build and Test Java Spring
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3

      - name: Create .env file
        run: |
          echo "DITTO_APP_ID=${{ secrets.DITTO_APP_ID }}" > .env
          echo "DITTO_PLAYGROUND_TOKEN=${{ secrets.DITTO_PLAYGROUND_TOKEN }}" >> .env
          echo "DITTO_AUTH_URL=${{ secrets.DITTO_AUTH_URL }}" >> .env
          echo "DITTO_WEBSOCKET_URL=${{ secrets.DITTO_WEBSOCKET_URL }}" >> .env

      - name: Cache Gradle dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Insert test document into Ditto Cloud
        run: |
          DOC_ID="ci_spring_test_${GITHUB_RUN_ID}_${GITHUB_RUN_NUMBER}"
          
          # Create inverted timestamp for alphabetical sorting (newest first)
          # Use a large number (9999999999) minus current timestamp so newer = smaller = sorts first
          CURRENT_TIMESTAMP=$(date +%s)
          INVERTED_TIMESTAMP=$((9999999999 - CURRENT_TIMESTAMP))
          SEED_TEXT="${INVERTED_TIMESTAMP}_ci_spring_test_${GITHUB_RUN_ID}_${GITHUB_RUN_NUMBER}"
          
          # Insert test document using Ditto API
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H 'Content-type: application/json' \
            -H "Authorization: Bearer ${{ secrets.DITTO_API_KEY }}" \
            -d "{
              \"statement\": \"INSERT INTO tasks DOCUMENTS (:newTask) ON ID CONFLICT DO UPDATE\",
              \"args\": {
                \"newTask\": {
                  \"_id\": \"${DOC_ID}\",
                  \"text\": \"${SEED_TEXT}\",
                  \"isCompleted\": false
                }
              }
            }" \
            "https://${{ secrets.DITTO_API_URL }}/api/v4/store/execute")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n-1)
          
          if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 201 ]; then
            echo "‚úì Test document inserted successfully: ${DOC_ID}"
            echo "‚úì Seed text: ${SEED_TEXT}"
            echo "‚úì Inverted timestamp: ${INVERTED_TIMESTAMP} (newer documents sort first)"
            echo "GITHUB_TEST_DOC_ID=${SEED_TEXT}" >> $GITHUB_ENV
          else
            echo "‚ùå Failed to insert test document (HTTP ${HTTP_CODE})"
            echo "Response: $BODY"
            exit 1
          fi

      - name: Run linter (PMD)
        working-directory: java-spring
        run: ./gradlew pmdMain pmdTest

      - name: Run static analysis (SpotBugs)
        working-directory: java-spring
        run: ./gradlew spotbugsMain

      - name: Build application
        working-directory: java-spring
        run: |
          ./gradlew bootJar
          echo "Spring Boot JAR built successfully"

      - name: Run Unit Tests
        working-directory: java-spring
        run: ./gradlew test --tests "QuickstartApplicationTests"

      - name: Run BrowserStack integration test (Java)
        working-directory: java-spring
        run: |
          # Set required environment variables for the integration test
          export BROWSERSTACK_USERNAME="${{ secrets.BROWSERSTACK_USERNAME }}"
          export BROWSERSTACK_ACCESS_KEY="${{ secrets.BROWSERSTACK_ACCESS_KEY }}"
          export DITTO_API_KEY="${{ secrets.DITTO_API_KEY }}"
          export DITTO_API_URL="${{ secrets.DITTO_API_URL }}"
          export GITHUB_TEST_DOC_ID="${{ env.GITHUB_TEST_DOC_ID }}"
          export GITHUB_ACTIONS="true"
          export GITHUB_RUN_ID="${{ github.run_id }}"
          
          # Run only the BrowserStack integration test
          ./gradlew test --tests "*BrowserStackIntegrationTest*"

      - name: Start Spring Boot application
        run: |
          cd java-spring
          echo "üöÄ Starting Spring Boot Ditto Tasks application..."
          
          # Start Spring Boot in background with explicit port
          nohup ./gradlew bootRun --args="--server.port=8080" > spring-boot.log 2>&1 &
          SPRING_PID=$!
          echo "SPRING_PID=$SPRING_PID" >> $GITHUB_ENV
          
          # Wait for application to be ready
          echo "‚è≥ Waiting for Spring Boot application to start..."
          for i in {1..60}; do
            if curl -s -f http://localhost:8080/ > /dev/null 2>&1; then
              echo "‚úÖ Spring Boot Ditto Tasks app is running at http://localhost:8080"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "‚ùå Spring Boot app failed to start within 60 seconds"
              cat spring-boot.log
              exit 1
            fi
            echo "Waiting for startup... ($i/60)"
            sleep 2
          done
          
          # Show the app is responding
          curl -s http://localhost:8080/ | head -10

      - name: Run BrowserStack web test on Spring Boot Ditto app
        id: browserstack_test  
        run: |
          # Check BrowserStack credentials
          if [ -z "${{ secrets.BROWSERSTACK_USERNAME }}" ] || [ -z "${{ secrets.BROWSERSTACK_ACCESS_KEY }}" ]; then
            echo "‚ùå BrowserStack credentials not available - this should fail locally"
            exit 1
          fi

          # Install Python Selenium
          pip install selenium requests

          # Create BrowserStack test script
          cat > browserstack_spring_test.py << 'EOF'
          import os
          import time
          from selenium import webdriver
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          from selenium.webdriver.chrome.options import Options

          # BrowserStack configuration
          username = os.environ['BROWSERSTACK_USERNAME']
          access_key = os.environ['BROWSERSTACK_ACCESS_KEY']
          test_doc_id = os.environ.get('GITHUB_TEST_DOC_ID', 'test-doc-id')

          desired_cap = {
              'browser': 'Chrome',
              'browser_version': 'latest',
              'os': 'Windows',
              'os_version': '10',
              'name': 'Spring Boot Ditto Tasks Test',
              'project': 'Android Spring Quickstart',
              'build': f'Build #{os.environ.get("GITHUB_RUN_NUMBER", "local")}',
              'sessionName': f'Spring Boot Ditto Sync Test - {test_doc_id}',
              'local': 'false',
              'seleniumVersion': '4.0.0',
              'debug': 'true',
              'video': 'true',
              'networkLogs': 'true',
              'consoleLogs': 'info'
          }

          # Connect to BrowserStack
          driver = webdriver.Remote(
              command_executor=f'https://{username}:{access_key}@hub-cloud.browserstack.com/wd/hub',
              desired_capabilities=desired_cap
          )

          try:
              print(f"üåê BrowserStack session started - you can view it in the dashboard")
              print(f"üìù Testing Spring Boot Ditto Tasks app with test document: {test_doc_id}")
              
              # Navigate to the Spring Boot Ditto app
              print("üîó Opening Spring Boot Ditto Tasks application...")
              driver.get("http://localhost:8080/")
              
              # Wait for page to load and take screenshot
              WebDriverWait(driver, 10).until(
                  EC.presence_of_element_located((By.TAG_NAME, "body"))
              )
              
              print("üì∏ Taking screenshot of Spring Boot Ditto Tasks app...")
              driver.save_screenshot("spring_boot_app.png")
              
              # Get page title and verify it's the Ditto app
              title = driver.title
              print(f"üìÑ Page title: {title}")
              
              # Look for Ditto-related elements
              try:
                  # Check if this looks like a tasks application
                  body_text = driver.find_element(By.TAG_NAME, "body").text.lower()
                  if "task" in body_text or "ditto" in body_text:
                      print("‚úÖ Confirmed this is the Ditto Tasks application")
                      driver.execute_script('browserstack_executor: {"action": "setSessionStatus", "arguments": {"status":"passed", "reason": "Spring Boot Ditto Tasks app loaded successfully"}}')
                  else:
                      print("‚ö†Ô∏è Page loaded but doesn't appear to be the Ditto Tasks app")
                      print(f"Page content preview: {body_text[:200]}...")
                      
              except Exception as e:
                  print(f"‚ö†Ô∏è Could not verify page content: {e}")
                  
              # Keep the session open for a moment so you can see it in BrowserStack
              print("‚è∏Ô∏è Keeping session open for 10 seconds so you can view it in BrowserStack dashboard...")
              time.sleep(10)
              
              print("üéâ BrowserStack test completed successfully!")
              
          except Exception as e:
              print(f"‚ùå BrowserStack test failed: {e}")
              driver.execute_script('browserstack_executor: {"action": "setSessionStatus", "arguments": {"status":"failed", "reason": f"Test failed: {str(e)}"}}')
              raise
          finally:
              driver.quit()
              print("üîö BrowserStack session ended")

          EOF

          # Run the BrowserStack test
          export BROWSERSTACK_USERNAME="${{ secrets.BROWSERSTACK_USERNAME }}"
          export BROWSERSTACK_ACCESS_KEY="${{ secrets.BROWSERSTACK_ACCESS_KEY }}"
          export GITHUB_TEST_DOC_ID="${{ env.GITHUB_TEST_DOC_ID }}"
          export GITHUB_RUN_NUMBER="${{ github.run_number }}"
          
          python browserstack_spring_test.py

      - name: Stop Spring Boot application
        if: always()
        run: |
          if [ -n "${{ env.SPRING_PID }}" ]; then
            echo "üõë Stopping Spring Boot application (PID: ${{ env.SPRING_PID }})"
            kill ${{ env.SPRING_PID }} 2>/dev/null || true
            sleep 2
            kill -9 ${{ env.SPRING_PID }} 2>/dev/null || true
          fi
          
          # Also kill any java processes running Spring Boot
          pkill -f "spring-boot" || true
          pkill -f "bootRun" || true

      - name: Generate test report
        if: always()
        run: |
          # Create test report
          echo "# Java Spring CI Test Report" > test-report.md
          echo "" >> test-report.md
          echo "**Build Status:** ${{ job.status }}" >> test-report.md
          echo "**GitHub Run ID:** ${{ github.run_id }}" >> test-report.md
          echo "" >> test-report.md
          
          echo "## Test Results" >> test-report.md
          echo "- ‚úÖ PMD static analysis completed" >> test-report.md
          echo "- ‚úÖ SpotBugs analysis completed" >> test-report.md
          echo "- ‚úÖ Spring Boot JAR build successful" >> test-report.md
          echo "- ‚úÖ Unit tests passed" >> test-report.md
          
          if [ "${{ steps.browserstack_test.outcome }}" = "success" ]; then
            echo "- ‚úÖ BrowserStack integration test passed" >> test-report.md
          else
            echo "- ‚ùå BrowserStack integration test failed" >> test-report.md
          fi
          
          echo "" >> test-report.md
          echo "## Ditto Cloud Verification" >> test-report.md
          echo "- **Test Document ID:** ${{ env.GITHUB_TEST_DOC_ID }}" >> test-report.md
          echo "- **Seeding Status:** ${{ steps.browserstack_test.outcome == 'success' && 'Success' || 'Failed' }}" >> test-report.md

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: java-spring-test-results
          path: |
            java-spring/build/libs/
            java-spring/build/reports/
            test-report.md

      - name: Comment PR with results
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ job.status }}';
            const runUrl = '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}';
            const testDocId = '${{ env.GITHUB_TEST_DOC_ID }}';
            const browserstackStatus = '${{ steps.browserstack_test.outcome }}';
            
            const body = `## ‚òï Java Spring CI Test Results
            
            **Status:** ${status === 'success' ? '‚úÖ Passed' : '‚ùå Failed'}
            **Build:** [#${{ github.run_number }}](${runUrl})
            **Test Document ID:** ${testDocId || 'Not generated'}
            
            ### Test Results:
            - ‚úÖ PMD static analysis completed
            - ‚úÖ SpotBugs analysis completed  
            - ‚úÖ Spring Boot JAR build successful
            - ‚úÖ Unit tests passed
            - ${browserstackStatus === 'success' ? '‚úÖ' : '‚ùå'} BrowserStack integration test (Ditto Cloud verification)
            
            ### Integration Test Details:
            This test verifies that:
            1. Test document is successfully seeded to Ditto Cloud
            2. Document can be queried back from Ditto Cloud
            3. **Should fail locally** (no BrowserStack credentials)
            4. **Should pass in CI** (with proper secrets configured)
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });