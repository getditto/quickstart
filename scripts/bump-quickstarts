#!/usr/bin/env bash
set -euo pipefail

# bump-quickstarts.sh â€” update Ditto quickstart app versions across many files in one pass
# Usage:
#   ./bump-quickstarts.sh -f 4.11.1 -t 4.11.4-rc.2 [options]
# Options:
#   -f, --from <ver>      Current version to replace (required)
#   -t, --to <ver>        New version to set (required)
#   -n, --dry-run         Show what would change; do not write files
#   -m, --manifest <path> File with one pattern per line (filenames or globs)
#   -a, --add <pattern>   Add an extra filename/glob to search (can repeat)
#   -r, --root <dir>      Repo root to scan (default: .)
#   --no-defaults         Do NOT include the built-in filename set
#   -v, --verbose         Print matched files and replacements
#   -h, --help            Show help
#
# Notes:
# - Patterns are matched as -name globs (e.g., "package.json", "*.csproj").
# - Matches occur recursively from --root.
# - Replacement is literal (no regex) and cross-platform via Perl's \Q...\E.
# - Requires Perl (preinstalled on macOS and most Linux distros). If Perl is
#   unavailable, the script will fall back to sed with macOS/GNU handling.

print_help() {
  sed -n '1,24p' "$0"
}

# Built-in filename set covering our quickstarts
DEFAULT_PATTERNS=(
  'libs.versions.toml'
  'package.json'
  'README.md'
  'DittoTasksApp.csproj'
  'build.gradle.kts'
  'DittoMauiTasksApp.csproj'
  'DittoDotNetTasksConsole.csproj'
)

FROM=""
TO=""
DRY_RUN=false
VERBOSE=false
ROOT="."
USE_DEFAULTS=true
EXTRA_PATTERNS=()
MANIFEST=""

# Parse args
while [[ $# -gt 0 ]]; do
  case "$1" in
  -f | --from)
    FROM="${2:-}"
    shift 2
    ;;
  -t | --to)
    TO="${2:-}"
    shift 2
    ;;
  -n | --dry-run)
    DRY_RUN=true
    shift
    ;;
  -m | --manifest)
    MANIFEST="${2:-}"
    shift 2
    ;;
  -a | --add)
    EXTRA_PATTERNS+=("${2:-}")
    shift 2
    ;;
  -r | --root)
    ROOT="${2:-}"
    shift 2
    ;;
  --no-defaults)
    USE_DEFAULTS=false
    shift
    ;;
  -v | --verbose)
    VERBOSE=true
    shift
    ;;
  -h | --help)
    print_help
    exit 0
    ;;
  *)
    echo "Unknown arg: $1" >&2
    print_help
    exit 1
    ;;
  esac
done

if [[ -z "$FROM" || -z "$TO" ]]; then
  echo "Error: --from and --to are required." >&2
  print_help
  exit 1
fi

# Collect patterns
PATTERNS=()
if $USE_DEFAULTS; then
  PATTERNS+=("${DEFAULT_PATTERNS[@]}")
fi
if [[ -n "$MANIFEST" ]]; then
  if [[ ! -f "$MANIFEST" ]]; then
    echo "Manifest not found: $MANIFEST" >&2
    exit 1
  fi
  while IFS= read -r line; do
    [[ -z "$line" || "$line" =~ ^# ]] && continue
    PATTERNS+=("$line")
  done <"$MANIFEST"
fi
PATTERNS+=("${EXTRA_PATTERNS[@]}")

if [[ ${#PATTERNS[@]} -eq 0 ]]; then
  echo "No patterns provided. Use --add or --manifest, or omit --no-defaults." >&2
  exit 1
fi

# De-duplicate patterns
mapfile -t PATTERNS < <(printf '%s\n' "${PATTERNS[@]}" | awk '!(seen[$0]++)')

# Build the find expression
FIND_ARGS=("$ROOT" -type f \()
for i in "${!PATTERNS[@]}"; do
  pat="${PATTERNS[$i]}"
  FIND_ARGS+=(-name "$pat")
  if [[ $i -lt $((${#PATTERNS[@]} - 1)) ]]; then
    FIND_ARGS+=(-o)
  fi
done
FIND_ARGS+=(\) -print0)

# Locate candidate files
mapfile -d '' FILES < <(find "${FIND_ARGS[@]}")

if [[ ${#FILES[@]} -eq 0 ]]; then
  echo "No files matched patterns under $ROOT" >&2
  exit 0
fi

if $VERBOSE; then
  echo "Matched ${#FILES[@]} files:" >&2
  printf ' - %s\n' "${FILES[@]}" >&2
fi

# Escape FROM for grep and sed; perl will use \Q...\E
ESC_FROM_REGEX=$(printf '%s' "$FROM" | sed -e 's/[.[\*^$]/\\&/g' -e 's/\//\\\//g')

# Preview changes if dry-run
if $DRY_RUN; then
  echo "-- DRY RUN --" >&2
  total=0
  for f in "${FILES[@]}"; do
    if grep -q -- "$FROM" "$f"; then
      count=$(grep -o -- "$FROM" "$f" | wc -l | tr -d ' ')
      ((total += count)) || true
      echo "Would update $f ($count occurrence(s))"
      if $VERBOSE; then
        grep -n -- "$FROM" "$f" || true
      fi
    fi
  done
  echo "Total occurrences: $total"
  exit 0
fi

# Replace using Perl if available; fallback to sed
if command -v perl >/dev/null 2>&1; then
  # Run in batches to avoid argv limits
  batch=()
  for f in "${FILES[@]}"; do
    batch+=("$f")
    if [[ ${#batch[@]} -ge 100 ]]; then
      perl -0777 -i -pe "s/\\Q$FROM\\E/$TO/g" "${batch[@]}"
      batch=()
    fi
  done
  if [[ ${#batch[@]} -gt 0 ]]; then
    perl -0777 -i -pe "s/\\Q$FROM\\E/$TO/g" "${batch[@]}"
  fi
else
  echo "Perl not found; falling back to sed" >&2
  # Determine sed -i flavor
  if sed --version >/dev/null 2>&1; then
    INPLACE=(sed -i)
  else
    INPLACE=(sed -i '')
  fi
  for f in "${FILES[@]}"; do
    "${INPLACE[@]}" "s|$ESC_FROM_REGEX|$TO|g" "$f"
  done
fi

echo "Updated ${#FILES[@]} file(s) from '${FROM}' to '${TO}'."

# Optional: show a short summary of touched files
if $VERBOSE; then
  for f in "${FILES[@]}"; do
    if grep -q -- "$TO" "$f"; then
      echo "OK: $f"
    fi
  done
fi

# Upgrade javascript-tui deps
cd javascript-tui
npm install

cd ../javascript-web
npm install

cd ..
